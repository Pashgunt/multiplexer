## Архитектурное решение

Создать единый сервис-маршрутизатор на Go, который заменит множественные процессы в скриптовых языках программирования.
Пример PHP и тд.

## Схема работы:

Эта схема планируется развиваться со временем.

```
┌─────────────────────────────────────────────┐
│               Сервис на Go                  │
│  (мультиплексор сообщений / роутер)         │
├─────────────────────────────────────────────┤
│  │    │    │    │    │                     │
│  Cons1 Cons2 Cons3 ... ConsN               │
│  (для каждого транспорта/топика/очереди)    │
├─────────────────────────────────────────────┤
│         HTTP/GRPC клиент                    │
└───────────────────────────────────┬─────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────┐
│           PHP сервисы (обработчики)              │
├─────────────────────────────────────────────────┤
│  │           │           │           │          │
│  Pod1       Pod2       Pod3       ... PodN      │
│  (горизонтальное масштабирование)               │
└─────────────────────────────────────────────────┘
```

## Ключевые компоненты:

### 1. **Сервис на Go (роутер/диспетчер)**
- **Брокеры сообщений**: RabbitMQ, Kafka, Redis Streams
- **Библиотеки Go**:
    - Для RabbitMQ: `rabbitmq/amqp091-gо`
    - Для Kafka: `segmentio/kafka-go`
    - Для Redis: `redis/go-redis`
- **Параллелизм**: goroutines + каналы (channels) для каждого потребителя
- **Конфигурация**: YAML с описанием всех транспортов и правил маршрутизации

### 2. **Протокол связи Go → PHP**
- **HTTP/REST** - первичный способ свзяи, в дальнейшем планируется добавить способы, описанные ниже
- **gRPC**
- **GraphQL**

## Поток данных:

1. **Потребление**: Go-сервис подключается ко всем транспортам одновременно
2. **Маршрутизация**: Определяет, в какой PHP-сервис отправить сообщение
3. **Доставка**: Отправляет сообщение через HTTP/gRPC
4. **Обработка**: PHP выполняет бизнес-логику
5. **Подтверждение**: Go подтверждает обработку (ack/nack) в брокере
6. **Ретри**: В случае ошибки реализует политику повторных попыток

## Дополнительные возможности Go-сервиса:

- **Кэширование**: Redis для хранения состояния
- **Метрики**: Prometheus-метрики для мониторинга
- **Трассировка**: OpenTelemetry для распределённой трассировки
- **Конфигурация**: Hot-reload конфигурации без перезапуска
- **Балансировка нагрузки**: Распределение между PHP-инстансами
- **Очередь сбоев (DLQ)**: Автоматическое управление проблемными сообщениями

## Преимущества подхода:

1. **Экономия ресурсов**: Один процесс вместо N PHP-процессов
2. **Управляемость**: Централизованное управление консьюмерами
3. **Надёжность**: Единая точка для ретраев и обработки ошибок
4. **Масштабируемость**: Независимое масштабирование Go и PHP частей
5. **Мультиязычность**: Можно подключать не только PHP, но и другие сервисы